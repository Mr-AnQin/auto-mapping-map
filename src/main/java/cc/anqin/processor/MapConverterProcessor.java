package cc.anqin.processor;

import cc.anqin.processor.annotation.AutoKeyMapping;
import cn.hutool.core.lang.Opt;
import cn.hutool.core.util.StrUtil;
import com.squareup.javapoet.*;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;

import cc.anqin.processor.annotation.AutoToMap;
import cc.anqin.processor.base.ConvertMap;

/**
 * <p>Map转换器处理器</p>
 *
 * @author Mr.An
 * @since 2024/11/18
 */
@SupportedAnnotationTypes("cc.anqin.processor.annotation.AutoToMap")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class MapConverterProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(AutoToMap.class)) {
            if (element instanceof TypeElement) {
                TypeElement typeElement = (TypeElement) element;
                generateToMapMethod(typeElement);
            }
        }
        return true;
    }

    private void generateToMapMethod(TypeElement typeElement) {
        String className = typeElement.getSimpleName() + ConvertMap.CLASS_SUFFIX;
        String packageName = processingEnv.getElementUtils().getPackageOf(typeElement).toString();

        System.out.println("Generating file: " + packageName + "." + className);

        // 创建 toMap 方法
        MethodSpec.Builder toMapBuilder = MethodSpec.methodBuilder("toMap")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .returns(ParameterizedTypeName.get(Map.class, String.class, Object.class))
                .addParameter(TypeName.get(typeElement.asType()), "entity");

        // 初始化 Map
        toMapBuilder.addStatement("$T<String, Object> map = new $T<>()", Map.class, HashMap.class);

        // 遍历字段（包含父类）
        collectFields(typeElement, toMapBuilder);

        toMapBuilder.addStatement("return map");

        MethodSpec toMapMethod = toMapBuilder.build();


        // 创建 Spring 的 @Generated 注解
        AnnotationSpec componentAnnotation = AnnotationSpec
                .builder(ClassName.get("cc.anqin.processor.annotation", "Generated"))
                .addMember("value", "$S", "cc.anqin.processor.MapConverterProcessor") // 添加生成器名称
                .addMember("date", "$S", LocalDateTime.now())        // 添加当前日期
                .addMember("comments", "$S", String.join("\n",
                        "Generated by MapConverterProcessor",
                        "Author: Mr.An",
                        "Introduction: https://anqin.cc/",
                        "Blog: https://blog.anqin.cc/"))   // 添加注释
                .build();

        // 创建实现 MappingConvert 接口的类
        TypeSpec mapConverterClass = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(componentAnnotation)
                .addSuperinterface(ParameterizedTypeName.get(
                        ClassName.get("cc.anqin.processor.base", "MappingConvert"),
                        TypeName.get(typeElement.asType())
                ))
                .addMethod(toMapMethod)
                .build();

        // 写入 Java 文件
        JavaFile javaFile = JavaFile.builder(packageName, mapConverterClass).build();
        try {
            javaFile.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 递归收集类及其父类的字段
     */
    private void collectFields(TypeElement typeElement, MethodSpec.Builder toMapBuilder) {
        // 获取当前类的字段
        List<? extends Element> enclosedElements = typeElement.getEnclosedElements();
        for (Element enclosed : enclosedElements) {
            if (enclosed instanceof VariableElement) {
                VariableElement field = (VariableElement) enclosed;

                // 跳过 final 字段
                if (field.getModifiers().contains(Modifier.FINAL)) {
                    continue;
                }

                // 检查字段是否被 @AutoKeyMapping 注解标记并获取目标名称
                String fieldName = field.getSimpleName().toString();
                AutoKeyMapping annotation = field.getAnnotation(AutoKeyMapping.class);

                // 跳过被标记为忽略的字段
                if (annotation != null && annotation.ignore()) {
                    continue;
                }

                // 确定目标字段名：优先取 annotation.target，否则默认使用 fieldName
                String targetFieldName = Opt.ofNullable(annotation)
                        .map(AutoKeyMapping::target)
                        .filter(StrUtil::isNotBlank)
                        .orElse(fieldName);

                String getterName = "get" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);

                // 使用 getter 方法获取字段值并放入 Map
                toMapBuilder.addStatement("map.put($S, entity.$L())", targetFieldName, getterName);
            }
        }

        // 递归获取父类字段
        TypeMirror superclass = typeElement.getSuperclass();
        if (superclass != null && !superclass.toString().equals("java.lang.Object")) {
            Element superElement = processingEnv.getTypeUtils().asElement(superclass);
            if (superElement instanceof TypeElement) {
                collectFields((TypeElement) superElement, toMapBuilder);
            }
        }
    }
}
